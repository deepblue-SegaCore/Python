Perfect! Let's proceed step by step.

## **1. Testing the Webhook with TradingView**

### **Step 1: Get Your Webhook URL**

Your webhook URL is:
```
https://amoeba-trading-backend.[your-username].repl.co/webhook/tradingview
```

To find your exact URL:
1. Look at your Replit webview URL
2. Add `/webhook/tradingview` to the end

### **Step 2: Configure TradingView Alert**

1. **In TradingView**, go to your chart with the Amoeba Trading System v2.2 indicator
2. **Create an Alert** (Alt+A or click the alarm clock icon)
3. **Configure the alert**:
   - Condition: Choose your Amoeba indicator alert condition
   - Alert name: "Amoeba Test Alert"
   - Message: Leave default or customize
   - **Webhook URL**: Paste your Replit URL
   - Click "Create"

### **Step 3: Test the Alert**

1. **Trigger the alert** (wait for market conditions or use Bar Replay to trigger)
2. **Check your Replit console** - you should see:
   ```
   Webhook received: {'text': 'AMOEBA: High Probability BULLISH Signal...'}
   ```

### **Step 4: Enhanced Test with JSON Format**

For better testing, update your Pine Script alert message to send JSON:

In your Pine Script, modify the alert message:
```pinescript
alertcondition(high_prob_bullish, 
    title="Amoeba: Enhanced BULLISH Intelligence", 
    message='{"symbol":"{{ticker}}","alert_type":"BULLISH","pressure":' + str.tostring(environmental_pressure) + ',"strength":' + str.tostring(adjusted_signal_strength) + ',"exchange":"{{exchange}}"}'
)
```

---

## **2. Redis Alternative for Pattern Memory**

Since Replit doesn't have built-in Redis, we have **three options**:

### **Option A: Use Python Dictionary (In-Memory) - Recommended for Start**
- Simple and immediate
- Data lost on restart
- Good for testing

### **Option B: Use SQLite (File-Based)**
- Persistent storage
- No external dependencies
- Included with Python

### **Option C: Use External Redis (Advanced)**
- Sign up for free Redis at [Redis Cloud](https://redis.com/try-free/)
- Get connection URL
- Best for production

**Let's start with Option A (in-memory) for simplicity.**

---

## **3. Food Source Intelligence Module (One Module at a Time)**

Here's the first module for Replit Assistant:

---

## **Copy this to Replit Assistant:**

Please create the Food Source Intelligence module with the following:

**1. Create a new file `app/intelligence.py` with this content:**

```python
"""
Food Source Intelligence Module
Implements Phase 2 10-point granular scoring system
Based on Technical Specification Section 4
"""
from typing import Dict, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime
from app.models import FoodSource, FoodQuantity, FoodQuality, Sustainability

@dataclass
class FoodSourceAssessment:
    """
    Enhanced Food Source Assessment with 10-point scoring
    Based on Phase 2 specifications
    """
    quantity: str  # SMALL, MEDIUM, LARGE
    quality: str   # LOW, MEDIUM, HIGH
    score: float   # 0-10 granular score
    sustainability: str  # LIMITED, MODERATE, GOOD, EXCELLENT, EXCEPTIONAL
    predicted_duration: str  # 30min-2h, 2-6h, 6-12h, 12-24h, 24-72h
    confidence: float
    rationale: Dict[str, str]  # Explanation of scoring

class FoodSourceIntelligence:
    """
    Implements Technical Specification Section 4: Food Source Intelligence
    Enhanced with Phase 2 10-point granular scoring
    """
    
    def __init__(self):
        # Scoring weights from specification
        self.quantity_weights = {
            'volume_surge': 2.0,      # 0-2 points
            'volume_trend': 1.0,      # 0-1 point
            'institutional_hours': 1.0, # 0-1 point
            'range_expansion': 1.0     # 0-1 point
        }
        
        self.quality_weights = {
            'resistance_level': 2.0,   # 0-2 points
            'directional_consistency': 1.0,  # 0-1 point
            'institutional_participation': 1.0,  # 0-1 point
            'timing_quality': 1.0,     # 0-1 point
            'market_structure': 1.0    # 0-1 point
        }
    
    def assess_food_source(self, alert_data: Dict) -> FoodSourceAssessment:
        """
        Main assessment function matching Specification 4.1
        Performs 10-point granular scoring
        """
        # Extract relevant data
        food_data = alert_data.get('food_source', {})
        
        # Calculate component scores
        quantity_score, quantity_details = self._calculate_quantity_score(alert_data)
        quality_score, quality_details = self._calculate_quality_score(alert_data)
        
        # Calculate 10-point granular score
        granular_score = self._calculate_granular_score(
            quantity_score, 
            quality_score,
            alert_data
        )
        
        # Determine classifications based on scores
        quantity = self._classify_quantity(quantity_score)
        quality = self._classify_quality(quality_score)
        sustainability = self._classify_sustainability(granular_score)
        duration = self._predict_duration(granular_score)
        
        # Build rationale
        rationale = {
            "quantity_factors": quantity_details,
            "quality_factors": quality_details,
            "score_calculation": f"Base: {quantity_score + quality_score}/10, Adjusted: {granular_score:.1f}/10",
            "grade": self._get_grade_description(granular_score)
        }
        
        return FoodSourceAssessment(
            quantity=quantity,
            quality=quality,
            score=round(granular_score, 1),
            sustainability=sustainability,
            predicted_duration=duration,
            confidence=alert_data.get('confidence', 0.5),
            rationale=rationale
        )
    
    def _calculate_quantity_score(self, alert_data: Dict) -> Tuple[int, str]:
        """Calculate food quantity score (0-5 points max)"""
        score = 0
        details = []
        
        # Volume surge contribution (0-2 points)
        volume_ratio = alert_data.get('volume_surge_ratio', 1.0)
        if volume_ratio > 1.5:
            score += 2
            details.append("Strong volume surge (2pts)")
        elif volume_ratio > 1.2:
            score += 1
            details.append("Moderate volume surge (1pt)")
        else:
            details.append("Normal volume (0pts)")
            
        # Volume trend contribution (0-1 point)
        volume_trend = alert_data.get('volume_trend_strength', 1.0)
        if volume_trend > 1.1:
            score += 1
            details.append("Accelerating volume (1pt)")
        else:
            details.append("Stable volume trend (0pts)")
            
        # Institutional hours (0-1 point)
        if alert_data.get('institutional_hours', False):
            score += 1
            details.append("Institutional hours (1pt)")
        else:
            details.append("Retail hours (0pts)")
            
        # Range expansion (0-1 point)
        range_expansion = alert_data.get('range_expansion', 1.0)
        if range_expansion > 1.2:
            score += 1
            details.append("Range expanding (1pt)")
        else:
            details.append("Normal range (0pts)")
            
        return score, ", ".join(details)
    
    def _calculate_quality_score(self, alert_data: Dict) -> Tuple[int, str]:
        """Calculate food quality score (0-6 points max)"""
        score = 0
        details = []
        
        # Resistance level (0-2 points)
        resistance = alert_data.get('resistance_level', 'NORMAL')
        if resistance == 'LIGHT':
            score += 2
            details.append("Light resistance (2pts)")
        elif resistance == 'NORMAL':
            score += 1
            details.append("Normal resistance (1pt)")
        else:
            details.append("Heavy resistance (0pts)")
            
        # Directional consistency (0-1 point)
        if alert_data.get('consistent_advancement', False) or \
           alert_data.get('consistent_decline', False):
            score += 1
            details.append("Directional consistency (1pt)")
        else:
            details.append("Choppy movement (0pts)")
            
        # Institutional participation (0-1 point)
        if alert_data.get('institutional_hours', False):
            score += 1
            details.append("Institutional timing (1pt)")
        else:
            details.append("Retail timing (0pts)")
            
        # Timing quality (0-1 point)
        if not alert_data.get('is_weekend_approach', False):
            score += 1
            details.append("Good timing (1pt)")
        else:
            details.append("Weekend approach (0pts)")
            
        # Market structure (0-1 point)
        structure = alert_data.get('market_structure', 'NORMAL')
        if structure != 'CONSTRAINED':
            score += 1
            details.append("Open structure (1pt)")
        else:
            details.append("Constrained structure (0pts)")
            
        return score, ", ".join(details)
    
    def _calculate_granular_score(self, quantity: int, quality: int, 
                                  alert_data: Dict) -> float:
        """
        Calculate 10-point granular score with environmental adjustments
        """
        # Base score (max 11 points scaled to 10)
        base_score = (quantity + quality) * 10 / 11
        
        # Environmental modifiers
        modifiers = 1.0
        
        # Emergency conditions reduce score
        if alert_data.get('alert_type') == 'EMERGENCY':
            modifiers *= 0.7
            
        # High confidence increases score
        confidence = alert_data.get('confidence', 0.5)
        if confidence > 0.8:
            modifiers *= 1.1
        elif confidence < 0.4:
            modifiers *= 0.9
            
        # Environmental pressure bonus
        pressure = alert_data.get('pressure', 1.0)
        threshold = alert_data.get('threshold', 1.5)
        if pressure > threshold * 1.5:
            modifiers *= 1.15  # Extreme pressure bonus
        elif pressure > threshold:
            modifiers *= 1.05  # Active pressure bonus
            
        # Apply modifiers
        final_score = base_score * modifiers
        
        # Ensure score stays within 0-10 range
        return min(10.0, max(0.0, final_score))
    
    def _classify_quantity(self, score: int) -> str:
        """Maps quantity score to classification"""
        if score >= 4:
            return "LARGE"
        elif score >= 2:
            return "MEDIUM"
        else:
            return "SMALL"
    
    def _classify_quality(self, score: int) -> str:
        """Maps quality score to classification"""
        if score >= 4:
            return "HIGH"
        elif score >= 2:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _classify_sustainability(self, score: float) -> str:
        """
        Maps 10-point score to sustainability rating
        Based on Phase 2 specifications
        """
        if score >= 9:
            return "EXCEPTIONAL"
        elif score >= 7:
            return "EXCELLENT"
        elif score >= 5:
            return "GOOD"
        elif score >= 3:
            return "MODERATE"
        else:
            return "LIMITED"
    
    def _predict_duration(self, score: float) -> str:
        """
        Predicts food source duration based on score
        Based on Phase 2 specifications
        """
        if score >= 9:
            return "24-72h"
        elif score >= 7:
            return "12-24h"
        elif score >= 5:
            return "6-12h"
        elif score >= 3:
            return "2-6h"
        else:
            return "30min-2h"
    
    def _get_grade_description(self, score: float) -> str:
        """
        Returns human-readable grade description
        """
        if score >= 9:
            return "ü•© PREMIUM GRADE - Exceptional institutional-quality opportunity"
        elif score >= 7:
            return "üçñ HIGH GRADE - Excellent sustained opportunity"
        elif score >= 5:
            return "ü•ò GOOD GRADE - Solid standard opportunity"
        elif score >= 3:
            return "üçû MODERATE GRADE - Limited quick opportunity"
        else:
            return "üçø LIMITED GRADE - Minimal scalp opportunity only"
```

**2. Update `app/webhooks.py` to use the intelligence module. Add these imports at the top:**

```python
from app.intelligence import FoodSourceIntelligence, FoodSourceAssessment
```

**3. Then update the webhook function in `app/webhooks.py` (replace the existing `tradingview_webhook` function):**

```python
@router.post("/tradingview")
async def tradingview_webhook(request: Request, body: Dict[str, Any] = Body(...)):
    """
    Main webhook endpoint for TradingView alerts
    Enhanced with Phase 2 Food Source Intelligence
    """
    try:
        # Initialize intelligence engine
        food_intel = FoodSourceIntelligence()
        
        # Log for debugging
        print(f"Webhook received: {body}")
        
        # Basic validation
        if not body:
            raise HTTPException(status_code=400, detail="Empty request body")
        
        # Extract key fields - handle both dict and string formats
        if isinstance(body, str):
            try:
                alert_data = json.loads(body)
            except json.JSONDecodeError:
                alert_data = {"message": body}
        else:
            alert_data = body
        
        # Perform food source assessment
        assessment = food_intel.assess_food_source(alert_data)
        
        # Process alert with enhanced intelligence
        response = {
            "status": "success",
            "message": "Alert received and processed with Phase 2 intelligence",
            "alert_type": alert_data.get("alert_type", "unknown"),
            "symbol": alert_data.get("symbol", "unknown"),
            "timestamp": datetime.utcnow().isoformat(),
            "food_source_assessment": {
                "score": assessment.score,
                "grade": assessment.rationale["grade"],
                "sustainability": assessment.sustainability,
                "predicted_duration": assessment.predicted_duration,
                "quantity": assessment.quantity,
                "quality": assessment.quality,
                "confidence": assessment.confidence,
                "details": assessment.rationale
            }
        }
        
        # Log the assessment
        print(f"Food Source Assessment: Score={assessment.score}/10, "
              f"Sustainability={assessment.sustainability}, "
              f"Duration={assessment.predicted_duration}")
        
        return response
        
    except Exception as e:
        print(f"Webhook error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

After implementing this:
1. Restart your server
2. Test with a webhook that includes food source data
3. Check the console for the enhanced assessment output

This module now provides 10-point granular scoring as specified in Phase 2!

---

**Copy all of the above to Replit Assistant to implement the Food Source Intelligence module.**